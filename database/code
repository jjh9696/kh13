create table soccer(
rank number(2), 
name varchar2(21), 
win number(2), 
draw number(2), 
lose number(2));
DROP TABLE soccer;

create table Savings( 
name varchar2(21), 
basic number(5,2),
prefer number(5,2),
monthly number, 
year number(3));
drop table savings

create table athlete(
name varchar2(21), 
event varchar2(11), 
season char(6), 
gold number(2), 
silver number(2), 
bronze number(2));
DROP TABLE ATHLETE;

--테이블을 만들고 데이터를 추가하도록 코드 작성

--테이블 생성
CREATE TABLE student(
name varchar2(21),
score number(3)
);

--데이터 추가
--insert into 테이블이름(형식들) values(값들);
--(주의) 오라클에서 문자열은 외따옴표를 쓴다
INSERT INTO student (name, score) VALUES ('홍길동', 50);

--데이터 조회
--select * from 테이블이름;
SELECT * FROM STUDENT ;

DROP TABLE STUDENT;


CREATE TABLE plan (
telecom char(2),
product varchar2(60),
monthly number,
data_gb number(4),
call_min number(4),
message number(4)
);
DROP TABLE PLAN;

INSERT INTO plan (telecom,product,monthly,data_gb,call_min,message)
VALUES ('SK','5G언택트52',52000,200,1000,2000);
INSERT INTO PLAN (telecom,product,monthly,data_gb,call_min,message)
VALUES ('KT','5G세이브',45000,100,900,1500);
INSERT INTO PLAN (telecom,product,monthly,data_gb,call_min,message)
VALUES ('LG','5G시그니처',130000,500,2000,2500);

SELECT * FROM PLAN;
DELETE FROM PLAN;

/*
	테이블 제약조건(table constraint)
	-테이블에 추가되는데이터에 대한 조건을 설정할 수 있다
	-종류는 null, 중복, 값의 범위 or 조건 등이 있다
	-null을 허용하지 않으려면 컬럼 옆에 not null 키워드를 추가한다
	-중복을 허용하지 않으려면 컬럼 옆에 unique 키워드를 추가한다
	-허용되는 값을 지정하려면 컬럼 옆에 check 키워드를 추가한다
*/

CREATE TABLE menu(
menu_name varchar2(60)NOT NULL UNIQUE
	check(regexp_like(menu_name,'^[가-힣]+$')),
menu_type varchar2(9)NOT NULL CHECK(menu_type IN ('디저트','음료')),
menu_price NUMBER NOT NULL CHECK(menu_price >=0),
--menu_event char(1)NOT NULL CHECK(menu_event = 'Y' OR menu_event = 'N')
menu_event char(1)NOT NULL CHECK(menu_event IN ('Y','N'))
);
DROP TABLE menu;

INSERT INTO menu(menu_name,menu_type,menu_price,menu_event)
values('아메리카노','디저트',3000,'N');
SELECT * FROM menu;

CREATE TABLE tariff( 
	Course varchar2(60)NOT NULL UNIQUE,
	Course_time NUMBER (3)NOT NULL CHECK(Course_time>0 and MOD(Course_time, 30)=0),
	fee number(8)NOT NULL CHECK(fee>0),
	division varchar2(12)NOT NULL CHECK(division IN ('온라인','오프라인','혼합'))
);
DROP TABLE tariff;
INSERT INTO tariff(Course,Course_time,fee,division)
	values('자바 마스터과정','90',1000000,'온라인');
INSERT INTO tariff(Course,Course_time,fee,division)
	values('파이썬 기초','60',600000,'온라인');
INSERT INTO tariff(Course,Course_time,fee,division)
	values('웹 개발자 단기완성','120',1200000,'오프라인');
SELECT * FROM tariff;

CREATE TABLE phone(
	phone_name varchar2(30)NOT NULL,
	phone_telecom char(2)NOT NULL CHECK(phone_telecom IN ('SK','KT','LG')),
	phone_price number(7)NOT NULL CHECK(phone_price>0),
	phone_agree varchar2(18)NOT NULL CHECK(phone_agree IN ('설정하지않음','24개월','36개월')),
	UNIQUE(phone_name, phone_telecom)
);
DROP TABLE phone;
INSERT INTO phone(phone_name,phone_telecom,phone_price,phone_agree)
	VALUES ('갤럭시Fold4','SK',1800000,'설정하지않음');
INSERT INTO phone(phone_name,phone_telecom,phone_price,phone_agree)
	VALUES ('갤럭시Fold4','KT',1750000,'24개월');
INSERT INTO phone(phone_name,phone_telecom,phone_price,phone_agree)
	VALUES ('아이폰15','LG',2000000,'36개월');
INSERT INTO phone(phone_name,phone_telecom,phone_price)
	VALUES ('아이폰15','KT',1990000,'설정하지않음');
SELECT * FROM phone;

/*
	기본키(primary key)
	-테이블에 단 한개만 설정 할 수 있는 유일한 불변값
	-대표항목 역할을 하며 not null + unique 효과를 가짐
	-회원으로 치면 "아이디"와 "닉네임" 중에서 "아이디"가 기본키 역할을 수행할 수 있다
	-모든 항목 중에 가장 검색 속도가 빠름
	-테이블 당 1개를 반드시 만들 것을 권장(없으면 번호라도 생성해서 지정)
*/

--포켓몬스터 테이블
CREATE TABLE pocketmon(
pocketmon_no NUMBER PRIMARY key,
pocketmon_name varchar2(30) NOT null,
pocketmon_type varchar2(9) NOT null
);
DROP TABLE pocketmon;
INSERT INTO pocketmon(pocketmon_no,pocketmon_name,pocketmon_type)
	values(1,'이상해씨','풀');
INSERT INTO pocketmon(pocketmon_no,pocketmon_name,pocketmon_type)
	values(4,'파이리','불꽃');
INSERT INTO pocketmon(pocketmon_no,pocketmon_name,pocketmon_type)
	values(7,'꼬부기','물');
SELECT * FROM pocketmon;

CREATE TABLE board(
board_no NUMBER PRIMARY key,
board_title varchar2(300)NOT NULL /*check(regexp_like(board_title,'^[가-힣 ]{1,100}$')) 제목에 한글만 들어가는 건 아님*/,
board_content varchar2(4000) NOT null,							
board_writer varchar2(20) check(regexp_like(board_writer,'^[a-zA-Z0-9]{8,20}$')),
board_readcount NUMBER DEFAULT 0 check(board_readcount >= 0)
);
DROP TABLE board;
INSERT INTO board (board_no, board_title, board_content, board_writer, board_readcount)
	VALUES (1, '첫 번째 게시글', '이 게시글은 첫 번째 게시글입니다.', 'user1234', 10);

INSERT INTO board (board_no, board_title, board_content, board_writer, board_readcount)
	VALUES (2, '두 번째 게시글', '두 번째 게시글의 내용입니다.', 'user2345', 15);

INSERT INTO board (board_no, board_title, board_content,board_writer, board_readcount)
	VALUES (3, '세 번째 게시글', '세 번째 게시글의 내용입니다. 길게 적기길게 적기길게 적기길게 적기길게 적기길게 적기길게 적기길게 적기길게 적기길게 적기길게 적기.', 'user3456', 5);

SELECT * FROM board;

/*
	시퀀스(sequence)
	-데이터베이스 객체 중 하나
	-번호 생성기
	-테이블과 세트로 사용하는 경우가 많으며 "기본키" 생성하는 목적으로 주로 사용
	
*/
DROP SEQUENCE product_seq;
CREATE SEQUENCE product_seq;
--create sequence product_seq nocache; 
DROP TABLE product;
CREATE TABLE product(
product_no NUMBER PRIMARY KEY,
product_name varchar2(60) NOT NULL,
product_price NUMBER NOT NULL
);

--시퀀스를 이용한 데이터 생성(시퀀스이름.nextval)
INSERT INTO product(product_no,product_name,product_price)
values(product_seq.nextval,'30인치 모니터',250000);
INSERT INTO product(product_no,product_name,product_price)
values(product_seq.nextval,'RTX 3080 Ti',1460000);

SELECT * FROM product;

--시퀀스의 자세한 정보 확인
SELECT * FROM USER_SEQUENCES;

/*
	날짜 데이터
	-date 또는 timestamp 형태를 사용
	-date는 초까지, timestamp는 밀리초까지 저장
	-java.sql.Date 클래스와 date 형태가 호환됨
	-java.sql.Timestamp 클래스와 timestamp 형태가 호환됨
	-연/월/일/시/분/초(+밀리초)가 모두 필요한 경우 사용한다
	-변환명령은 to_date()
	-변환 형식 : Y(연도),M(월),D(일), HH/HH24(시간), MI(분), S(초) (소문자로 써도 됨)
	-현재시각을 구하는 키워드가 존재(sysdate/systimestamp)
	-날짜는 더하기 빼기가 가능(단위:일)
*/ 
DROP SEQUENCE funding_seq;
CREATE SEQUENCE funding_seq;
DROP TABLE funding;
CREATE TABLE funding(
funding_no NUMBER PRIMARY KEY,
funding_title varchar2(90) NOT NULL,
funding_dest NUMBER NOT NULL,
funding_begin DATE NOT NULL,
funding_end DATE NOT NULL
);
--날짜는 문자열로도 설정이 가능하다(문자열로만 하려면 년월일만 입력하는 경우만 가능)
INSERT INTO funding(funding_no,funding_title,funding_dest,funding_begin,funding_end)
values(funding_seq.nextval,'자바 서적',500000,'2024-01-10','2024-01-31');
--변환 명령을 사용하면 더 정확하게 형식을 지정할 수 있다
--to_date(값,형식)
INSERT INTO funding(funding_no,funding_title,funding_dest,funding_begin,funding_end)
values(funding_seq.nextval,'데이터베이스 서적',600000,to_date('2024-01-10','YYYY-MM-DD'),to_date('2024-01-31','YYYY-MM-DD'));
INSERT INTO funding(funding_no,funding_title,funding_dest,funding_begin,funding_end)
values(funding_seq.nextval,'웹 개발 서적',700000,to_date('2024-01-05 10:58:30','YYYY-MM-DD HH24:MI:SS'),to_date('2024-01-31 23:59:59','YYYY-MM-DD HH24:MI:SS'));
INSERT INTO funding(funding_no,funding_title,funding_dest,funding_begin,funding_end)
values(funding_seq.nextval,'클라우드 서적',750000,sysdate,to_date('2024-01-31 23:59:59','YYYY-MM-DD HH24:MI:SS'));
INSERT INTO funding(funding_no,funding_title,funding_dest,funding_begin,funding_end)
values(funding_seq.nextval,'한달짜리 펀딩',750000,sysdate,sysdate+30);
SELECT * FROM funding;


-- book 테이블
drop sequence book_seq;
create sequence book_seq;

drop table book;
create table book(
book_id number primary key,
book_title varchar2(300) not null,
book_author varchar2(90) 
	check(regexp_like(book_author, '^[^!@#$]+$')),
book_publication_date char(10) 
	check(regexp_like(book_publication_date, '^([0-9]{4})-(02-(0[1-9]|1[0-9]|2[0-8])|(0[469]|11)-(0[1-9]|1[0-9]|2[0-9]|30)|(0[13578]|1[02])-(0[1-9]|1[0-9]|2[0-9]|3[01]))$')),
book_price number default 0 not null check(book_price >= 0),
book_publisher varchar2(90),
book_page_count number not null check(book_page_count >= 1),
book_genre varchar2(15) not null
);

INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(1, 'Harry Potter 1', 'J.K. Rowling', '2001-06-26', 19.99, 'Scholastic', 320, 'Fantasy');
INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(2, 'To Kill a Mockingbird', 'Harper Lee', '1960-07-11', 14.99, 'Grand Central Publishing', 336, 'Classic');
INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(3, 'The Great Gatsby', 'F. Scott Fitzgerald', '1925-04-10', 12.99, 'Scribner', 180, 'Classic');
INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(4, '1984', 'George Orwell', '1949-06-08', 10.99, 'Secker & Warburg', 328, 'Dystopian');
INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(5, 'Pride and Prejudice', 'Jane Austen', '1813-01-28', 9.99, 'Penguin Classics', 432, 'Romance');
INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(6, 'The Hobbit', 'J.R.R. Tolkien', '1937-09-21', 15.99, 'Houghton Mifflin Harcourt', 320, 'Fantasy');
INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(7, 'The Catcher in the Rye', 'J.D. Salinger', '1951-07-16', 11.99, 'Little, Brown and Company', 224, 'Classic');
INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(8, 'Lord of the Rings', 'J.R.R. Tolkien', '1954-07-29', 29.99, 'Allen & Unwin', 1178, 'Fantasy');
INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(9, 'To the Lighthouse', 'Virginia Woolf', '1927-05-05', 13.99, 'Harcourt, Brace and Company', 209, 'Modernist');
INSERT INTO BOOK(book_id, book_title, book_author, book_publication_date, book_price, book_publisher, book_page_count, book_genre) 
	VALUES(10, 'The Alchemist', 'Paulo Coelho', '1988-06-01', 9.99, 'HarperOne', 208, 'Fiction');
select * from book;
ROLLBACK;--지금까지의 작업내용을 취소
commit;--지금까지의 작업내용을 저장
/*
	조회(SELECT)
	-데이터베이스에 저장된 데이터들을 원하는 기준에 맞게 읽어내는 것
	-SELECT 항목 FROM 테이블
*/

-- 전체 도서 조회
select * from book;
select book.* from book;

-- 도서명만 조회
select book_title from book;

-- 도서명과 페이지수만 조회
select book_title, book_page_count from book;

-- 항목을 계산하여 추가로 조회할 수 있다
select book_title, length(book_title) from book;
select book_title 도서제목, length(book_title) 제목글자수 from book;
select book_title "도서 제목", length(book_title) "제목 글자수" from book;

-- 도서명과 출간년도를 조회하고 싶은 경우
-- substr(항목, 시작위치, 글자수) : 오라클은 문자열 위치 시작이 1부터
select 
	book_title 도서명, 
	substr(book_publication_date, 1, 4) 출간년도 
from book;

/*
	조건
	-제시한 조건에 부합하는 데이터만 조회(필터링)
	-조회구문 뒤에 'where 조건식'을 추가
*/

--10달러 미만인 도서만 조회
SELECT * FROM book WHERE book_price<10;


--10~15달러 사이의 도서만 조회
SELECT * FROM book WHERE book_price>=10 and book_price<=15;
SELECT * FROM book WHERE book_price BETWEEN 10 AND 15;

--5번 도서만 조회
SELECT * FROM book WHERE book_id=5;
--5번만 빼고
SELECT * FROM book WHERE book_id!=5;

--문자 조건
--[1] 장르가 Fantasy인 도서를 조회
SELECT * FROM book WHERE book_genre='Fantasy';
SELECT * FROM book WHERE LOWER(book_genre)='fantasy'; --소문자로 바꿔서 조회

--[2] T로 시작하는 도서 조회
--like 연산자는 패턴을 지정할 때 사용하며 %는 해당 자리는 무관하다는 뜻
--instr 함수는 지정한 글자가 어느 위치에 있는지 알아내는 명령
--시작 검사만큼은 like 연산자가 매우 빠르며, 나머지는 전반적으로 instr 함수가 빠르다
SELECT * FROM book WHERE book_title LIKE 'T%';--시작하는 거 찾을 때 빠름(다른건 느림)
SELECT * FROM book WHERE instr(book_title,'T')=1;

SELECT * FROM book WHERE lower(book_title) LIKE '%h%';
SELECT * FROM book WHERE instr(lower(book_title),'h')>0;--추천

SELECT * FROM book WHERE book_author LIKE 'J%';--추천
SELECT * FROM book WHERE instr(book_author,'J')=1;

SELECT * FROM book WHERE book_publisher LIKE '%Company';
SELECT * FROM book WHERE instr(book_publisher,'Company')=LENGTH(book_publisher)-LENGTH('company')+1;

SELECT * FROM book WHERE REGEXP_LIKE(book_title, '[0-9]+');

DROP TABLE product;
create table product(
no number primary key,
name varchar2(30) not null,
type varchar2(15) check(type in ('과자','아이스크림','주류','사탕')),
price number,
made date,
expire date
);

insert into product values(1, '스크류바', '아이스크림', 1200, '2020-05-01', '2020-10-01');
insert into product values(2, '마이쮸', '사탕', 900, '2020-01-01', '2021-01-01');
insert into product values(3, '초코파이', '과자', 3000, '2020-01-01', '2021-01-01');
insert into product values(4, '맛동산', '과자', 2200, '2020-02-01', '2020-10-20');
insert into product values(5, '참이슬', '주류', 1000, '2020-01-05', '2020-04-05');
insert into product values(6, '처음처럼', '주류', 1000, '2020-03-15', '2020-08-15');
insert into product values(7, '바나나킥', '과자', 1500, '2020-05-03', '2020-06-03');
insert into product values(8, '빠삐코', '아이스크림', 1000, '2019-12-01', '2020-06-01');
insert into product values(9, '멘토스', '사탕', 1200, '2020-03-20', '2020-12-31');
insert into product values(10, '오레오', '과자', 2100, '2019-06-01', '2020-06-01');
SELECT * FROM product;
ROLLBACK;--지금까지의 작업내용을 취소
commit;--지금까지의 작업내용을 저장
/*
	날짜 조건
	-특정 항목을 검사하거나 기간으로 검색하는 경우가 많다
*/
SELECT * FROM product;

--2020년에 제조된 상품 조회
SELECT *FROM product WHERE EXTRACT (YEAR FROM made)=2020;
SELECT *FROM product WHERE TO_CHAR(made, 'YYYY')='2020';--자료형도 맞춰줘야 한다
SELECT *FROM product WHERE 
	made >= TO_DATE('2020-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS') 
	AND 
	made <= to_date('2020-12-31 23:59:59', 'YYYY-MM-DD HH24:MI:SS');
SELECT *FROM product WHERE 
	made BETWEEN 
	TO_DATE('2020-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS') 
	AND 
	to_date('2020-12-31 23:59:59', 'YYYY-MM-DD HH24:MI:SS');

--(Q)여름에 제조한 상품 목록 조회(6,7,8월)
SELECT *FROM product WHERE EXTRACT (MONTH FROM made)in(6,7,8);
SELECT *FROM product WHERE EXTRACT (MONTH FROM made)BETWEEN 6 AND 8;
SELECT *FROM product WHERE TO_CHAR(made, 'MM')IN('06','07','08');
SELECT *FROM product WHERE TO_CHAR(made, 'MM')BETWEEN '06' AND '08';
--(Q)2019년 하반기에 제조한 상품 목록 조회(7~12월)
SELECT *FROM product WHERE EXTRACT (YEAR FROM made)=2019 AND EXTRACT (MONTH FROM made)BETWEEN 7 AND 12;
SELECT *FROM product WHERE REGEXP_LIKE(to_char(made,'YYYY-MM'),'^2019-(0[7-9]|1[0-2])$');
SELECT *FROM product WHERE TO_CHAR(made, 'YYYY')='2019'AND TO_CHAR(made, 'MM')IN('07','08','09','10','11','12');
SELECT *FROM product WHERE TO_CHAR(made, 'YYYY')='2019'AND TO_CHAR(made, 'MM')BETWEEN '07' AND '12';
--(Q)2020년 이후에 현재까지 제조한 상품 목록 조회
SELECT *FROM product WHERE 
	made BETWEEN 
	TO_DATE('2020-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS') 
	AND SYSDATE;
SELECT * FROM product WHERE TO_CHAR(made, 'YYYY') >= '2020';
--(Q)최근 5년간 제조한 상품 목록 조회
SELECT *FROM product WHERE 
	made BETWEEN 
	SYSDATE-(365*5)
	AND SYSDATE;

/*
	정렬(order by)
	-조건으로 데이터까지 다 골라냈다면 원하는 기준에 맞게 정렬할 수 있다
	-조회 구문의 마지막에 'order by 항목 asc/desc'를 적는다
	-(중요) 조건보다 뒤에 작성되어야 한다
*/

SELECT *FROM book;
SELECT * FROM product;

SELECT *FROM book ORDER BY book_id ASC;--오름차순
SELECT *FROM book ORDER BY book_id DESC;--내림차순

--(Q)상품을 최근 제조한 순으로 조회(최신순)
SELECT *FROM PRODUCT ORDER BY made DESC,NO ASC ;
--(Q)상품을 이름순으로 출력
SELECT *FROM PRODUCT ORDER BY name ASC,NO ASC ;
--(Q)상품을 종류별로 가격이 비싼 순으로 출력
SELECT *FROM PRODUCT ORDER BY TYPE ASC,price DESC,NO ASC ;
--(Q)유통기한이 가장 짧은 상품부터 출력
SELECT *FROM PRODUCT ORDER BY expire-made ASC,NO ASC;
SELECT product.*,expire-made 유통기한 FROM PRODUCT ORDER BY expire-made ASC,NO ASC;
SELECT product.*,expire-made 유통기한 FROM PRODUCT ORDER BY 유통기한 ASC,NO ASC;



/*
 	구조화된 질의어
	Structure Query Language
	
				FE(화면단)	BE(서버단)	
	(사용자) -> (화면(어플)) -> (서버(가게)) -> DB
										(DBMS)(창고)
			<-			<-			<-
 */


/*
	수정(update)
	-update 테이블명 set 변경구문 [where 조건]
	-사실상 조건은 무조건 사용한다고 봐야 하며, 특히 PK(기본키(Primary Key) 조건이 많이 쓰임
*/

--모든 상품의 가격을 0으로 변경
UPDATE PRODUCT SET PRICE=0;

--모든 상품의 종류를 과자로, 가격을 100원으로 변경
UPDATE PRODUCT SET TYPE='과자', PRICE = 100;

--1번 상품의 가격을 2000원으로 변경
UPDATE PRODUCT SET price=2000 WHERE NO=1;
--(주의사항) 없는 번호도 실행은 된다 (Updated rows를 보면 0이 나오는 것을 확인)
UPDATE PRODUCT SET price=2000 WHERE NO=100;

--(Q) 멘토스의 가격을 1000원으로 변경하고 분류를 과자로 변경
UPDATE PRODUCT SET price=1000 , TYPE='과자' WHERE NO=9;
--(Q) 과자의 가격을 500원 할인(오라클에는 누적연산이 없습니다)
UPDATE PRODUCT SET price= price-500 WHERE TYPE='과자';
--(Q) 아이스크림의 가격을 10% 인상(오라클에는 누적연산이 없습니다)
UPDATE PRODUCT SET price= price+price/10 WHERE TYPE='아이스크림';

SELECT * FROM product;
ROLLBACK;


/*
	삭제(delete)
	delete
	-전체를 지울 일은 거의 존재하지 않으므로 조건을 결합하여 사용
*/

-- 전체 삭제
delete product;--추천
delete from product;--가능하지만 비추천(select와 햇갈림)

-- 1번 상품 삭제
delete product where no=1;

-- (Q) 과자와 아이스크림 삭제
delete product where type='과자' or type='아이스크림';
delete product where type in ('과자', '아이스크림');

-- (Q) 2020년 상반기에 생산된 제품 삭제
delete product where made between 
	to_date('2020-01-01 00:00:00', 'YYYY-MM-DD HH24:MI:SS') 
	and 
	to_date('2020-06-30 23:59:59', 'YYYY-MM-DD HH24:MI:SS');

select * from product;
SELECT *
FROM product WHERE price < 1000 ORDER BY price ASC;
rollback;

DROP sequence emp_seq;
create sequence emp_seq;
DROP TABLE emp;
create table emp(
		emp_no number primary key,--사원번호, 시퀀스로 자동 부여
		emp_name varchar2(21) not null,--사원의 한글 이름
		emp_dept varchar2(30) not null,--사원의 소속 부서
		emp_date char(10) not null,--사원의 입사일
		emp_sal number default 0 not null check(emp_sal >= 0)--사원의 급여(원)
		);
SELECT *FROM emp;
INSERT INTO emp (emp_no, emp_name, emp_dept, emp_date, emp_sal)
VALUES (emp_seq.NEXTVAL, '김철수', '인사부', '2022-01-10', 5000000);
INSERT INTO emp (emp_no, emp_name, emp_dept, emp_date, emp_sal)
VALUES (emp_seq.NEXTVAL, '이영희', '영업부', '2022-02-15', 6000000);
INSERT INTO emp (emp_no, emp_name, emp_dept, emp_date, emp_sal)
VALUES (emp_seq.NEXTVAL, '박민준', '개발부', '2022-03-20', 7000000);
INSERT INTO emp (emp_no, emp_name, emp_dept, emp_date, emp_sal)
VALUES (emp_seq.NEXTVAL, '정지영', '마케팅부', '2022-04-25', 5500000);
INSERT INTO emp (emp_no, emp_name, emp_dept, emp_date, emp_sal)
VALUES (emp_seq.NEXTVAL, '홍길동', '기획부', '2022-05-30', 8000000);
SELECT *FROM emp;
COMMIT;
ROLLBACK;

DROP sequence menu_seq;
create sequence menu_seq;
DROP table menu;
create table menu(
menu_no number primary key,--메뉴번호, 시퀀스로 자동 부여
menu_name_kor varchar2(60) not null,--메뉴 한글 이름
menu_name_eng varchar2(60) not null,--메뉴 영문 이름
menu_type varchar2(30) not null,--메뉴 종류
menu_price number default 0 not null check(menu_price >= 0)--메뉴 판매가(원)
);
SELECT *FROM menu;
SELECT menu_seq.nextval FROM dual;
ALTER SEQUENCE menu_seq INCREMENT BY 1;

SELECT * FROM POCKETMON;

UPDATE POCKETMON SET POCKETMON_NAME = ?,POCKETMON_TYPE=?
WHERE POCKETMON_NO =?;

INSERT INTO POCKETMON (POCKETMON_NO, POCKETMON_NAME, POCKETMON_TYPE)
VALUES (25,'피카츄','전기');
SELECT * FROM POCKETMON;
SELECT * FROM POCKETMON WHERE POCKETMON_NAME LIKE '피카'||'%';
SELECT * FROM POCKETMON WHERE instr(POCKETMON_NAME, '?')>0;
COMMIT;

DROP TABLE MEMBER;
create table member (
member_id VARCHAR2(20) PRIMARY KEY check(regexp_like(member_id, '^[a-z][a-z0-9]{7,19}$')),
member_pw VARCHAR2(15) NOT NULL check(regexp_like(member_pw, '^[A-Za-z0-9!@#$]{6,15}$') and
    regexp_like(member_pw, '[A-Z]+')
    and
    regexp_like(member_pw, '[a-z]+')
    and
    regexp_like(member_pw, '[0-9]+')
    and
    regexp_like(member_pw, '[!@#$]+')),
member_nick VARCHAR2(30) NOT NULL UNIQUE check(regexp_like(member_nick, '^[가-힣][가-힣0-9]{1,9}$')),
member_birth VARCHAR2(10) check(regexp_like(member_birth, '^[0-9]{4}-(0[1-9]|1[0-2])-([0-2][1-9]|3[0-1])$')),
member_contact VARCHAR2(11) check(regexp_like(member_contact, '^[0-9]{1,3}[0-9]{1,8}$')),
member_email VARCHAR2(60) NOT NULL,
member_post VARCHAR2(6)check(regexp_like(member_post, '^[0-9]{5,6}$')),
member_address1 VARCHAR2(300),
member_address2 VARCHAR2(300),
member_level VARCHAR2(12) DEFAULT '일반회원' not null CHECK(member_level IN ('일반회원', '우수회원', '관리자')),
member_point number DEFAULT 0 not null check(member_point >= 0),
member_join DATE DEFAULT SYSDATE not null,
member_login DATE
);
insert into member(member_id, member_pw, member_nick, member_email)
values('testuser1', 'Testuser1!', '테스트유저1', 'testuser1@khacademy.com');
commit;
SELECT * FROM MEMBER;

/*SELECT * FROM MEMBER
COMMIT;
create table member(
member_id varchar2(20) primary key,
member_pw varchar2(15) not null,
member_nick varchar2(30) not null unique,
member_birth char(10),
member_contact char(11),
member_email varchar2(60) not null,
member_post varchar2(6),
member_address1 varchar2(300),
member_address2 varchar2(300),
member_level varchar2(12) default '일반회원' not null ,
member_point number default 0 not null,
member_join date default sysdate not null,
member_login date,
--check는 항목을 선언한 뒤에 작성할 수 있다
--이렇게 할경우 주소처럼 여러컬럼을 동시에 검사하는 작업을 할 수 있다
--check를 항목 옆에 쓰면 해당 항목만 검사가 가능하다
check(regexp_like(member_id, '^[a-z][a-z0-9]{7,19}$')),
check(regexp_like(member_pw, '^[A-Za-z0-9!@#$]{6,15}$')
    and
    regexp_like(member_pw, '[A-Z]+')
    and
    regexp_like(member_pw, '[a-z]+')
    and
    regexp_like(member_pw, '[0-9]+')
    and
    regexp_like(member_pw, '[!@#$]+')
),
check(regexp_like(member_nick, '^[가-힣][가-힣0-9]{1,9}$')),
check(regexp_like(member_contact, '^010[1-9][0-9]{3}[0-9]{4}$')),
check(regexp_like(member_birth, '^(19[0-9]{2}|20[0-9]{2})-(02-(0[1-9]|1[0-9]|2[0-8])|(0[469]|11)-(0[1-9]|1[0-9]|2[0-9]|30)|(0[13578]|1[02])-(0[1-9]|1[0-9]|2[0-9]|3[01]))$')),
check(regexp_like(member_email, '@')),
check(regexp_like(member_post, '^[0-9]{5,6}$')),
check((member_post is null and member_address1 is null and member_address2 is null)
    or
    (member_post is not null and member_address1 is not null and member_address2 is not null)
),
check(member_level in ('일반회원','우수회원','관리자')),
check(member_point >= 0)
);
drop table member;


insert into member(member_id, member_pw, member_nick, member_email)
values('testuser1', 'Testuser1!', '테스트유저1', 'testuser1@khacademy.com');
commit;*/


/*
	외래키
	
 */


/*
외래키(Foreign Key)
- 다른 테이블과 연결하기 위해 사용하는 도구
- 1대 N 관계 같은 구조적으로 결합되어 있는 형태를 구현할 때 사용
- 데이터의 안정성이 올라간다
<외래키 옵션>
- 외래키 뒤에 on delete를 붙이면 삭제 시 자동 처리를 지시할 수 있다
[1] on delete cascade를 붙이면 상위 항목이 지워지면 하위 항목이 삭제된다
[2] on delete set null을 붙이면 상위 항목이 지워지면 하위 항목의 외래키 값이 null로 변경된다
[3] on delete를 안붙이면 하위 항목이 있으면 상위 항목을 지울 수 없다
 */

-- 포켓몬스터 테이블
create table monster(
monster_no number primary key,
monster_name varchar2(30) not null
);
-- 포켓몬스터 속성 테이블
create table monster_attr(
--monster_no references monster(monster_no),
--monster_no references monster(monster_no) on delete cascade,
monster_no references monster(monster_no) on delete set null,
attr_name varchar2(30) not null
);

-- 1, 이상해씨, 풀/독
insert into monster(monster_no, monster_name) values(1, '이상해씨');
insert into monster_attr(monster_no, attr_name) values(1, '풀');
insert into monster_attr(monster_no, attr_name) values(1, '독');
commit;

-- 4, 파이리, 불
insert into monster(monster_no, monster_name) values(4, '파이리');
insert into monster_attr(monster_no, attr_name) values(4, '불');
commit;

--7번 꼬부기,물
INSERT INTO monster(monster_no, monster_name) values(7,'꼬부기');
INSERT INTO monster_attr(monster_no, attr_name) values(7,'물');
COMMIT;

-- 1번(이상해씨) 삭제
--delete monster_attr where monster_no=1;
delete monster where monster_no=1;
rollback;

SELECT *FROM MENU;
SELECT *FROM EMP;
SELECT *FROM POCKETMON;
SELECT *FROM POCKETMON WHERE POCKETMON_NO=66;

UPDATE MENU SET MENU_PRICE=MENU_PRICE + 1 WHERE MENU_NO=4;  

-- 시퀀스 생성
CREATE SEQUENCE student_seq;

-- 학생 테이블 생성
CREATE TABLE student (
  student_id NUMBER PRIMARY KEY,
  name VARCHAR2(50) NOT NULL,
  korean_score NUMBER CHECK (korean_score >= 0 AND korean_score <= 100) NOT NULL,
  math_score NUMBER CHECK (math_score >= 0 AND math_score <= 100) NOT NULL,
  english_score NUMBER CHECK (english_score >= 0 AND english_score <= 100) NOT NULL
);
SELECT *FROM student;
